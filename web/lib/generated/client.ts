import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};

export type ApiKey = {
  __typename?: 'ApiKey';
  apiKey: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  projectId: Scalars['ID'];
  role: Role;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type Collection = {
  __typename?: 'Collection';
  createdAt: Scalars['ISO8601DateTime'];
  defaultSortDirection: OrderDirection;
  defaultSortField: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  projectId: Scalars['ID'];
  rackFields?: Maybe<Array<RackField>>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CollectionInput = {
  id?: Maybe<Scalars['ID']>;
  projectId: Scalars['ID'];
  name: Scalars['String'];
  displayName: Scalars['String'];
  description: Scalars['String'];
  defaultSortField?: Maybe<Scalars['String']>;
  defaultSortDirection?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateApiKey */
export type CreateApiKeyInput = {
  projectId: Scalars['ID'];
  name: Scalars['String'];
  role: Role;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCollection */
export type CreateCollectionInput = {
  input: CollectionInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  input: ProjectInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateRackRow */
export type CreateRackRowInput = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  input: Array<RackRowItemInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCollection */
export type DeleteCollectionInput = {
  id: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  id: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteRackRow */
export type DeleteRackRowInput = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  rackRowId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export enum Field {
  Text = 'TEXT',
  Number = 'NUMBER',
  Checkbox = 'CHECKBOX',
  Email = 'EMAIL',
  Location = 'LOCATION',
  Markdown = 'MARKDOWN',
  Image = 'IMAGE',
  List = 'LIST',
  Barcode = 'BARCODE',
  Qrcode = 'QRCODE'
}

export enum FilterOperator {
  Eq = 'EQ',
  Lte = 'LTE',
  Gte = 'GTE',
  Lt = 'LT',
  Gt = 'GT',
  Ne = 'NE'
}



export type Mutation = {
  __typename?: 'Mutation';
  createApiKey?: Maybe<ApiKey>;
  createCollection?: Maybe<Collection>;
  createProject?: Maybe<Project>;
  createRackRow?: Maybe<RackRow>;
  deleteCollection?: Maybe<Collection>;
  deleteProject?: Maybe<Project>;
  deleteRackRow?: Maybe<Scalars['String']>;
  revokeApiKey?: Maybe<ApiKey>;
  revokeUserKey?: Maybe<User>;
  saveField?: Maybe<Array<RackField>>;
  signUp?: Maybe<User>;
  updateCollection?: Maybe<Collection>;
  updateProject?: Maybe<Project>;
  updateRackRow?: Maybe<RackRow>;
};


export type MutationCreateApiKeyArgs = {
  input: CreateApiKeyInput;
};


export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};


export type MutationCreateRackRowArgs = {
  input: CreateRackRowInput;
};


export type MutationDeleteCollectionArgs = {
  input: DeleteCollectionInput;
};


export type MutationDeleteProjectArgs = {
  input: DeleteProjectInput;
};


export type MutationDeleteRackRowArgs = {
  input: DeleteRackRowInput;
};


export type MutationRevokeApiKeyArgs = {
  input: RevokeApiKeyInput;
};


export type MutationRevokeUserKeyArgs = {
  input: RevokeUserKeyInput;
};


export type MutationSaveFieldArgs = {
  input: SaveFieldInput;
};


export type MutationSignUpArgs = {
  input: SignUpInput;
};


export type MutationUpdateCollectionArgs = {
  input: UpdateCollectionInput;
};


export type MutationUpdateProjectArgs = {
  input: UpdateProjectInput;
};


export type MutationUpdateRackRowArgs = {
  input: UpdateRackRowInput;
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type Project = {
  __typename?: 'Project';
  apiKeys?: Maybe<Array<ApiKey>>;
  collections: Array<Collection>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  userId: Scalars['ID'];
};

export type ProjectInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  collection: Collection;
  project: Project;
  projects: Array<Project>;
  rackField: RackField;
  rackRow: RackRow;
  rackRows: Array<RackRow>;
  rackRowsCount: Scalars['Int'];
};


export type QueryCollectionArgs = {
  id: Scalars['ID'];
  projectId: Scalars['ID'];
};


export type QueryProjectArgs = {
  id: Scalars['ID'];
};


export type QueryProjectsArgs = {
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['Int']>;
};


export type QueryRackFieldArgs = {
  id: Scalars['ID'];
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
};


export type QueryRackRowArgs = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  rackRowId: Scalars['ID'];
};


export type QueryRackRowsArgs = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['Int']>;
  filters?: Maybe<Array<RackRowFilter>>;
  orders?: Maybe<Array<RackRowOrder>>;
};


export type QueryRackRowsCountArgs = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
};

export type RackField = {
  __typename?: 'RackField';
  collectionId: Scalars['ID'];
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fieldType: Field;
  id: Scalars['ID'];
  name: Scalars['String'];
  order: Scalars['Int'];
  requiredField?: Maybe<Scalars['Boolean']>;
  sortable: Scalars['Boolean'];
  stored?: Maybe<Scalars['Boolean']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type RackFieldInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  fieldType: Field;
  order: Scalars['Int'];
  sortable: Scalars['Boolean'];
  stored?: Maybe<Scalars['Boolean']>;
  requiredField?: Maybe<Scalars['Boolean']>;
};

export type RackRow = {
  __typename?: 'RackRow';
  createdAt: Scalars['ISO8601DateTime'];
  data: Scalars['JSON'];
  id: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type RackRowFilter = {
  field: Scalars['String'];
  op?: FilterOperator;
  value: Scalars['String'];
};

export type RackRowItemInput = {
  rackFieldId: Scalars['ID'];
  name: Scalars['String'];
  data?: Maybe<Scalars['String']>;
};

export type RackRowOrder = {
  field: Scalars['String'];
  direction?: Maybe<OrderDirection>;
};

/** Autogenerated input type of RevokeApiKey */
export type RevokeApiKeyInput = {
  id: Scalars['ID'];
  projectId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RevokeUserKey */
export type RevokeUserKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export enum Role {
  ReadOnly = 'READ_ONLY',
  ReadAndWrite = 'READ_AND_WRITE'
}

/** Autogenerated input type of SaveField */
export type SaveFieldInput = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  input: Array<RackFieldInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SignUp */
export type SignUpInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCollection */
export type UpdateCollectionInput = {
  input: CollectionInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  input: ProjectInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRackRow */
export type UpdateRackRowInput = {
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  rackRowId: Scalars['ID'];
  input: Array<RackRowItemInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type User = {
  __typename?: 'User';
  apiKey?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type SignUpMutationVariables = Exact<{
  input: SignUpInput;
}>;


export type SignUpMutation = { __typename?: 'Mutation', signUp?: Maybe<{ __typename?: 'User', id: string, apiKey?: Maybe<string> }> };

export type CreateApiKeyMutationVariables = Exact<{
  input: CreateApiKeyInput;
}>;


export type CreateApiKeyMutation = { __typename?: 'Mutation', createApiKey?: Maybe<{ __typename?: 'ApiKey', id: string, name: string, apiKey: string, role: Role }> };

export type RevokeApiKeyMutationVariables = Exact<{
  input: RevokeApiKeyInput;
}>;


export type RevokeApiKeyMutation = { __typename?: 'Mutation', revokeApiKey?: Maybe<{ __typename?: 'ApiKey', id: string, name: string, apiKey: string, role: Role }> };

export type CreateCollectionMutationVariables = Exact<{
  input: CollectionInput;
}>;


export type CreateCollectionMutation = { __typename?: 'Mutation', createCollection?: Maybe<{ __typename?: 'Collection', id: string, projectId: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }> };

export type UpdateCollectionMutationVariables = Exact<{
  input: CollectionInput;
}>;


export type UpdateCollectionMutation = { __typename?: 'Mutation', updateCollection?: Maybe<{ __typename?: 'Collection', id: string, projectId: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }> };

export type DeleteCollectionMutationVariables = Exact<{
  input: DeleteCollectionInput;
}>;


export type DeleteCollectionMutation = { __typename?: 'Mutation', deleteCollection?: Maybe<{ __typename?: 'Collection', id: string, projectId: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }> };

export type SaveFieldMutationVariables = Exact<{
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  input: Array<RackFieldInput> | RackFieldInput;
}>;


export type SaveFieldMutation = { __typename?: 'Mutation', saveField?: Maybe<Array<{ __typename?: 'RackField', id: string, name: string, displayName: string, description?: Maybe<string>, fieldType: Field, order: number, sortable: boolean, stored?: Maybe<boolean>, requiredField?: Maybe<boolean> }>> };

export type CreateProjectMutationVariables = Exact<{
  input: ProjectInput;
}>;


export type CreateProjectMutation = { __typename?: 'Mutation', createProject?: Maybe<{ __typename?: 'Project', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string>, userId: string, createdAt: any, updatedAt: any, collections: Array<{ __typename?: 'Collection', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }> }> };

export type UpdateProjectMutationVariables = Exact<{
  input: ProjectInput;
}>;


export type UpdateProjectMutation = { __typename?: 'Mutation', updateProject?: Maybe<{ __typename?: 'Project', id: string }> };

export type DeleteProjectMutationVariables = Exact<{
  input: DeleteProjectInput;
}>;


export type DeleteProjectMutation = { __typename?: 'Mutation', deleteProject?: Maybe<{ __typename?: 'Project', id: string, name?: Maybe<string>, description?: Maybe<string> }> };

export type CreateRackRowMutationVariables = Exact<{
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  input: Array<RackRowItemInput> | RackRowItemInput;
}>;


export type CreateRackRowMutation = { __typename?: 'Mutation', createRackRow?: Maybe<{ __typename?: 'RackRow', id: string }> };

export type UpdateRackRowMutationVariables = Exact<{
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  rackRowId: Scalars['ID'];
  input: Array<RackRowItemInput> | RackRowItemInput;
}>;


export type UpdateRackRowMutation = { __typename?: 'Mutation', updateRackRow?: Maybe<{ __typename?: 'RackRow', id: string }> };

export type DeleteRackRowMutationVariables = Exact<{
  input: DeleteRackRowInput;
}>;


export type DeleteRackRowMutation = { __typename?: 'Mutation', deleteRackRow?: Maybe<string> };

export type CollectionQueryVariables = Exact<{
  id: Scalars['ID'];
  projectId: Scalars['ID'];
}>;


export type CollectionQuery = { __typename?: 'Query', collection: { __typename?: 'Collection', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string>, defaultSortField: string, defaultSortDirection: OrderDirection, projectId: string, createdAt: any, updatedAt: any, rackFields?: Maybe<Array<{ __typename?: 'RackField', id: string, name: string, displayName: string, description?: Maybe<string>, fieldType: Field, order: number, sortable: boolean, stored?: Maybe<boolean>, requiredField?: Maybe<boolean>, collectionId: string, createdAt: any, updatedAt: any }>> } };

export type ProjectQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ProjectQuery = { __typename?: 'Query', project: { __typename?: 'Project', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string>, userId: string, createdAt: any, updatedAt: any, collections: Array<{ __typename?: 'Collection', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }>, apiKeys?: Maybe<Array<{ __typename?: 'ApiKey', id: string, name: string, apiKey: string, role: Role }>> } };

export type ProjectsQueryVariables = Exact<{ [key: string]: never; }>;


export type ProjectsQuery = { __typename?: 'Query', projects: Array<{ __typename?: 'Project', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string>, userId: string, createdAt: any, updatedAt: any, collections: Array<{ __typename?: 'Collection', id: string, name?: Maybe<string>, displayName?: Maybe<string>, description?: Maybe<string> }> }> };

export type RackFieldQueryVariables = Exact<{
  id: Scalars['ID'];
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
}>;


export type RackFieldQuery = { __typename?: 'Query', rackField: { __typename?: 'RackField', id: string, name: string, displayName: string, fieldType: Field, description?: Maybe<string>, order: number, sortable: boolean, stored?: Maybe<boolean>, requiredField?: Maybe<boolean>, createdAt: any, updatedAt: any } };

export type RackRowQueryVariables = Exact<{
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  rackRowId: Scalars['ID'];
}>;


export type RackRowQuery = { __typename?: 'Query', rackRow: { __typename?: 'RackRow', id: string, data: any, createdAt: any, updatedAt: any } };

export type RackRowsQueryVariables = Exact<{
  projectId: Scalars['ID'];
  collectionId: Scalars['ID'];
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['Int']>;
  filters?: Maybe<Array<RackRowFilter> | RackRowFilter>;
  orders?: Maybe<Array<RackRowOrder> | RackRowOrder>;
}>;


export type RackRowsQuery = { __typename?: 'Query', total: number, rackRows: Array<{ __typename?: 'RackRow', id: string, data: any, createdAt: any, updatedAt: any }> };


export const SignUpDocument = gql`
    mutation signUp($input: SignUpInput!) {
  signUp(input: $input) {
    id
    apiKey
  }
}
    `;
export type SignUpMutationFn = Apollo.MutationFunction<SignUpMutation, SignUpMutationVariables>;

/**
 * __useSignUpMutation__
 *
 * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signUpMutation, { data, loading, error }] = useSignUpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignUpMutation(baseOptions?: Apollo.MutationHookOptions<SignUpMutation, SignUpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument, options);
      }
export type SignUpMutationHookResult = ReturnType<typeof useSignUpMutation>;
export type SignUpMutationResult = Apollo.MutationResult<SignUpMutation>;
export type SignUpMutationOptions = Apollo.BaseMutationOptions<SignUpMutation, SignUpMutationVariables>;
export const CreateApiKeyDocument = gql`
    mutation createApiKey($input: CreateApiKeyInput!) {
  createApiKey(input: $input) {
    id
    name
    apiKey
    role
  }
}
    `;
export type CreateApiKeyMutationFn = Apollo.MutationFunction<CreateApiKeyMutation, CreateApiKeyMutationVariables>;

/**
 * __useCreateApiKeyMutation__
 *
 * To run a mutation, you first call `useCreateApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createApiKeyMutation, { data, loading, error }] = useCreateApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<CreateApiKeyMutation, CreateApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateApiKeyMutation, CreateApiKeyMutationVariables>(CreateApiKeyDocument, options);
      }
export type CreateApiKeyMutationHookResult = ReturnType<typeof useCreateApiKeyMutation>;
export type CreateApiKeyMutationResult = Apollo.MutationResult<CreateApiKeyMutation>;
export type CreateApiKeyMutationOptions = Apollo.BaseMutationOptions<CreateApiKeyMutation, CreateApiKeyMutationVariables>;
export const RevokeApiKeyDocument = gql`
    mutation revokeApiKey($input: RevokeApiKeyInput!) {
  revokeApiKey(input: $input) {
    id
    name
    apiKey
    role
  }
}
    `;
export type RevokeApiKeyMutationFn = Apollo.MutationFunction<RevokeApiKeyMutation, RevokeApiKeyMutationVariables>;

/**
 * __useRevokeApiKeyMutation__
 *
 * To run a mutation, you first call `useRevokeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeApiKeyMutation, { data, loading, error }] = useRevokeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<RevokeApiKeyMutation, RevokeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeApiKeyMutation, RevokeApiKeyMutationVariables>(RevokeApiKeyDocument, options);
      }
export type RevokeApiKeyMutationHookResult = ReturnType<typeof useRevokeApiKeyMutation>;
export type RevokeApiKeyMutationResult = Apollo.MutationResult<RevokeApiKeyMutation>;
export type RevokeApiKeyMutationOptions = Apollo.BaseMutationOptions<RevokeApiKeyMutation, RevokeApiKeyMutationVariables>;
export const CreateCollectionDocument = gql`
    mutation createCollection($input: CollectionInput!) {
  createCollection(input: {input: $input}) {
    id
    projectId
    name
    displayName
    description
  }
}
    `;
export type CreateCollectionMutationFn = Apollo.MutationFunction<CreateCollectionMutation, CreateCollectionMutationVariables>;

/**
 * __useCreateCollectionMutation__
 *
 * To run a mutation, you first call `useCreateCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCollectionMutation, { data, loading, error }] = useCreateCollectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCollectionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCollectionMutation, CreateCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCollectionMutation, CreateCollectionMutationVariables>(CreateCollectionDocument, options);
      }
export type CreateCollectionMutationHookResult = ReturnType<typeof useCreateCollectionMutation>;
export type CreateCollectionMutationResult = Apollo.MutationResult<CreateCollectionMutation>;
export type CreateCollectionMutationOptions = Apollo.BaseMutationOptions<CreateCollectionMutation, CreateCollectionMutationVariables>;
export const UpdateCollectionDocument = gql`
    mutation updateCollection($input: CollectionInput!) {
  updateCollection(input: {input: $input}) {
    id
    projectId
    name
    displayName
    description
  }
}
    `;
export type UpdateCollectionMutationFn = Apollo.MutationFunction<UpdateCollectionMutation, UpdateCollectionMutationVariables>;

/**
 * __useUpdateCollectionMutation__
 *
 * To run a mutation, you first call `useUpdateCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCollectionMutation, { data, loading, error }] = useUpdateCollectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCollectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCollectionMutation, UpdateCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCollectionMutation, UpdateCollectionMutationVariables>(UpdateCollectionDocument, options);
      }
export type UpdateCollectionMutationHookResult = ReturnType<typeof useUpdateCollectionMutation>;
export type UpdateCollectionMutationResult = Apollo.MutationResult<UpdateCollectionMutation>;
export type UpdateCollectionMutationOptions = Apollo.BaseMutationOptions<UpdateCollectionMutation, UpdateCollectionMutationVariables>;
export const DeleteCollectionDocument = gql`
    mutation deleteCollection($input: DeleteCollectionInput!) {
  deleteCollection(input: $input) {
    id
    projectId
    name
    displayName
    description
  }
}
    `;
export type DeleteCollectionMutationFn = Apollo.MutationFunction<DeleteCollectionMutation, DeleteCollectionMutationVariables>;

/**
 * __useDeleteCollectionMutation__
 *
 * To run a mutation, you first call `useDeleteCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCollectionMutation, { data, loading, error }] = useDeleteCollectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCollectionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCollectionMutation, DeleteCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCollectionMutation, DeleteCollectionMutationVariables>(DeleteCollectionDocument, options);
      }
export type DeleteCollectionMutationHookResult = ReturnType<typeof useDeleteCollectionMutation>;
export type DeleteCollectionMutationResult = Apollo.MutationResult<DeleteCollectionMutation>;
export type DeleteCollectionMutationOptions = Apollo.BaseMutationOptions<DeleteCollectionMutation, DeleteCollectionMutationVariables>;
export const SaveFieldDocument = gql`
    mutation saveField($projectId: ID!, $collectionId: ID!, $input: [RackFieldInput!]!) {
  saveField(
    input: {projectId: $projectId, collectionId: $collectionId, input: $input}
  ) {
    id
    name
    displayName
    description
    fieldType
    order
    sortable
    stored
    requiredField
  }
}
    `;
export type SaveFieldMutationFn = Apollo.MutationFunction<SaveFieldMutation, SaveFieldMutationVariables>;

/**
 * __useSaveFieldMutation__
 *
 * To run a mutation, you first call `useSaveFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveFieldMutation, { data, loading, error }] = useSaveFieldMutation({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSaveFieldMutation(baseOptions?: Apollo.MutationHookOptions<SaveFieldMutation, SaveFieldMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveFieldMutation, SaveFieldMutationVariables>(SaveFieldDocument, options);
      }
export type SaveFieldMutationHookResult = ReturnType<typeof useSaveFieldMutation>;
export type SaveFieldMutationResult = Apollo.MutationResult<SaveFieldMutation>;
export type SaveFieldMutationOptions = Apollo.BaseMutationOptions<SaveFieldMutation, SaveFieldMutationVariables>;
export const CreateProjectDocument = gql`
    mutation createProject($input: ProjectInput!) {
  createProject(input: {input: $input}) {
    id
    name
    displayName
    description
    collections {
      id
      name
      displayName
      description
    }
    userId
    createdAt
    updatedAt
  }
}
    `;
export type CreateProjectMutationFn = Apollo.MutationFunction<CreateProjectMutation, CreateProjectMutationVariables>;

/**
 * __useCreateProjectMutation__
 *
 * To run a mutation, you first call `useCreateProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProjectMutation, { data, loading, error }] = useCreateProjectMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateProjectMutation(baseOptions?: Apollo.MutationHookOptions<CreateProjectMutation, CreateProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProjectMutation, CreateProjectMutationVariables>(CreateProjectDocument, options);
      }
export type CreateProjectMutationHookResult = ReturnType<typeof useCreateProjectMutation>;
export type CreateProjectMutationResult = Apollo.MutationResult<CreateProjectMutation>;
export type CreateProjectMutationOptions = Apollo.BaseMutationOptions<CreateProjectMutation, CreateProjectMutationVariables>;
export const UpdateProjectDocument = gql`
    mutation updateProject($input: ProjectInput!) {
  updateProject(input: {input: $input}) {
    id
  }
}
    `;
export type UpdateProjectMutationFn = Apollo.MutationFunction<UpdateProjectMutation, UpdateProjectMutationVariables>;

/**
 * __useUpdateProjectMutation__
 *
 * To run a mutation, you first call `useUpdateProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProjectMutation, { data, loading, error }] = useUpdateProjectMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateProjectMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProjectMutation, UpdateProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProjectMutation, UpdateProjectMutationVariables>(UpdateProjectDocument, options);
      }
export type UpdateProjectMutationHookResult = ReturnType<typeof useUpdateProjectMutation>;
export type UpdateProjectMutationResult = Apollo.MutationResult<UpdateProjectMutation>;
export type UpdateProjectMutationOptions = Apollo.BaseMutationOptions<UpdateProjectMutation, UpdateProjectMutationVariables>;
export const DeleteProjectDocument = gql`
    mutation deleteProject($input: DeleteProjectInput!) {
  deleteProject(input: $input) {
    id
    name
    description
  }
}
    `;
export type DeleteProjectMutationFn = Apollo.MutationFunction<DeleteProjectMutation, DeleteProjectMutationVariables>;

/**
 * __useDeleteProjectMutation__
 *
 * To run a mutation, you first call `useDeleteProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProjectMutation, { data, loading, error }] = useDeleteProjectMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteProjectMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProjectMutation, DeleteProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProjectMutation, DeleteProjectMutationVariables>(DeleteProjectDocument, options);
      }
export type DeleteProjectMutationHookResult = ReturnType<typeof useDeleteProjectMutation>;
export type DeleteProjectMutationResult = Apollo.MutationResult<DeleteProjectMutation>;
export type DeleteProjectMutationOptions = Apollo.BaseMutationOptions<DeleteProjectMutation, DeleteProjectMutationVariables>;
export const CreateRackRowDocument = gql`
    mutation createRackRow($projectId: ID!, $collectionId: ID!, $input: [RackRowItemInput!]!) {
  createRackRow(
    input: {projectId: $projectId, collectionId: $collectionId, input: $input}
  ) {
    id
  }
}
    `;
export type CreateRackRowMutationFn = Apollo.MutationFunction<CreateRackRowMutation, CreateRackRowMutationVariables>;

/**
 * __useCreateRackRowMutation__
 *
 * To run a mutation, you first call `useCreateRackRowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRackRowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRackRowMutation, { data, loading, error }] = useCreateRackRowMutation({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRackRowMutation(baseOptions?: Apollo.MutationHookOptions<CreateRackRowMutation, CreateRackRowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRackRowMutation, CreateRackRowMutationVariables>(CreateRackRowDocument, options);
      }
export type CreateRackRowMutationHookResult = ReturnType<typeof useCreateRackRowMutation>;
export type CreateRackRowMutationResult = Apollo.MutationResult<CreateRackRowMutation>;
export type CreateRackRowMutationOptions = Apollo.BaseMutationOptions<CreateRackRowMutation, CreateRackRowMutationVariables>;
export const UpdateRackRowDocument = gql`
    mutation updateRackRow($projectId: ID!, $collectionId: ID!, $rackRowId: ID!, $input: [RackRowItemInput!]!) {
  updateRackRow(
    input: {projectId: $projectId, collectionId: $collectionId, rackRowId: $rackRowId, input: $input}
  ) {
    id
  }
}
    `;
export type UpdateRackRowMutationFn = Apollo.MutationFunction<UpdateRackRowMutation, UpdateRackRowMutationVariables>;

/**
 * __useUpdateRackRowMutation__
 *
 * To run a mutation, you first call `useUpdateRackRowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRackRowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRackRowMutation, { data, loading, error }] = useUpdateRackRowMutation({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *      rackRowId: // value for 'rackRowId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateRackRowMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRackRowMutation, UpdateRackRowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRackRowMutation, UpdateRackRowMutationVariables>(UpdateRackRowDocument, options);
      }
export type UpdateRackRowMutationHookResult = ReturnType<typeof useUpdateRackRowMutation>;
export type UpdateRackRowMutationResult = Apollo.MutationResult<UpdateRackRowMutation>;
export type UpdateRackRowMutationOptions = Apollo.BaseMutationOptions<UpdateRackRowMutation, UpdateRackRowMutationVariables>;
export const DeleteRackRowDocument = gql`
    mutation deleteRackRow($input: DeleteRackRowInput!) {
  deleteRackRow(input: $input)
}
    `;
export type DeleteRackRowMutationFn = Apollo.MutationFunction<DeleteRackRowMutation, DeleteRackRowMutationVariables>;

/**
 * __useDeleteRackRowMutation__
 *
 * To run a mutation, you first call `useDeleteRackRowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRackRowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRackRowMutation, { data, loading, error }] = useDeleteRackRowMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteRackRowMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRackRowMutation, DeleteRackRowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRackRowMutation, DeleteRackRowMutationVariables>(DeleteRackRowDocument, options);
      }
export type DeleteRackRowMutationHookResult = ReturnType<typeof useDeleteRackRowMutation>;
export type DeleteRackRowMutationResult = Apollo.MutationResult<DeleteRackRowMutation>;
export type DeleteRackRowMutationOptions = Apollo.BaseMutationOptions<DeleteRackRowMutation, DeleteRackRowMutationVariables>;
export const CollectionDocument = gql`
    query collection($id: ID!, $projectId: ID!) {
  collection(id: $id, projectId: $projectId) {
    id
    name
    displayName
    description
    rackFields {
      id
      name
      displayName
      description
      fieldType
      order
      sortable
      stored
      requiredField
      collectionId
      createdAt
      updatedAt
    }
    defaultSortField
    defaultSortDirection
    projectId
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useCollectionQuery__
 *
 * To run a query within a React component, call `useCollectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionQuery({
 *   variables: {
 *      id: // value for 'id'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useCollectionQuery(baseOptions: Apollo.QueryHookOptions<CollectionQuery, CollectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionQuery, CollectionQueryVariables>(CollectionDocument, options);
      }
export function useCollectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionQuery, CollectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionQuery, CollectionQueryVariables>(CollectionDocument, options);
        }
export type CollectionQueryHookResult = ReturnType<typeof useCollectionQuery>;
export type CollectionLazyQueryHookResult = ReturnType<typeof useCollectionLazyQuery>;
export type CollectionQueryResult = Apollo.QueryResult<CollectionQuery, CollectionQueryVariables>;
export function refetchCollectionQuery(variables?: CollectionQueryVariables) {
      return { query: CollectionDocument, variables: variables }
    }
export const ProjectDocument = gql`
    query project($id: ID!) {
  project(id: $id) {
    id
    name
    displayName
    description
    collections {
      id
      name
      displayName
      description
    }
    apiKeys {
      id
      name
      apiKey
      role
    }
    userId
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useProjectQuery__
 *
 * To run a query within a React component, call `useProjectQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useProjectQuery(baseOptions: Apollo.QueryHookOptions<ProjectQuery, ProjectQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectQuery, ProjectQueryVariables>(ProjectDocument, options);
      }
export function useProjectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectQuery, ProjectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectQuery, ProjectQueryVariables>(ProjectDocument, options);
        }
export type ProjectQueryHookResult = ReturnType<typeof useProjectQuery>;
export type ProjectLazyQueryHookResult = ReturnType<typeof useProjectLazyQuery>;
export type ProjectQueryResult = Apollo.QueryResult<ProjectQuery, ProjectQueryVariables>;
export function refetchProjectQuery(variables?: ProjectQueryVariables) {
      return { query: ProjectDocument, variables: variables }
    }
export const ProjectsDocument = gql`
    query projects {
  projects {
    id
    name
    displayName
    description
    collections {
      id
      name
      displayName
      description
    }
    userId
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useProjectsQuery__
 *
 * To run a query within a React component, call `useProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectsQuery({
 *   variables: {
 *   },
 * });
 */
export function useProjectsQuery(baseOptions?: Apollo.QueryHookOptions<ProjectsQuery, ProjectsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectsQuery, ProjectsQueryVariables>(ProjectsDocument, options);
      }
export function useProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectsQuery, ProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectsQuery, ProjectsQueryVariables>(ProjectsDocument, options);
        }
export type ProjectsQueryHookResult = ReturnType<typeof useProjectsQuery>;
export type ProjectsLazyQueryHookResult = ReturnType<typeof useProjectsLazyQuery>;
export type ProjectsQueryResult = Apollo.QueryResult<ProjectsQuery, ProjectsQueryVariables>;
export function refetchProjectsQuery(variables?: ProjectsQueryVariables) {
      return { query: ProjectsDocument, variables: variables }
    }
export const RackFieldDocument = gql`
    query rackField($id: ID!, $projectId: ID!, $collectionId: ID!) {
  rackField(id: $id, projectId: $projectId, collectionId: $collectionId) {
    id
    name
    displayName
    fieldType
    description
    order
    sortable
    stored
    requiredField
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useRackFieldQuery__
 *
 * To run a query within a React component, call `useRackFieldQuery` and pass it any options that fit your needs.
 * When your component renders, `useRackFieldQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRackFieldQuery({
 *   variables: {
 *      id: // value for 'id'
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *   },
 * });
 */
export function useRackFieldQuery(baseOptions: Apollo.QueryHookOptions<RackFieldQuery, RackFieldQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RackFieldQuery, RackFieldQueryVariables>(RackFieldDocument, options);
      }
export function useRackFieldLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RackFieldQuery, RackFieldQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RackFieldQuery, RackFieldQueryVariables>(RackFieldDocument, options);
        }
export type RackFieldQueryHookResult = ReturnType<typeof useRackFieldQuery>;
export type RackFieldLazyQueryHookResult = ReturnType<typeof useRackFieldLazyQuery>;
export type RackFieldQueryResult = Apollo.QueryResult<RackFieldQuery, RackFieldQueryVariables>;
export function refetchRackFieldQuery(variables?: RackFieldQueryVariables) {
      return { query: RackFieldDocument, variables: variables }
    }
export const RackRowDocument = gql`
    query rackRow($projectId: ID!, $collectionId: ID!, $rackRowId: ID!) {
  rackRow(
    projectId: $projectId
    collectionId: $collectionId
    rackRowId: $rackRowId
  ) {
    id
    data
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useRackRowQuery__
 *
 * To run a query within a React component, call `useRackRowQuery` and pass it any options that fit your needs.
 * When your component renders, `useRackRowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRackRowQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *      rackRowId: // value for 'rackRowId'
 *   },
 * });
 */
export function useRackRowQuery(baseOptions: Apollo.QueryHookOptions<RackRowQuery, RackRowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RackRowQuery, RackRowQueryVariables>(RackRowDocument, options);
      }
export function useRackRowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RackRowQuery, RackRowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RackRowQuery, RackRowQueryVariables>(RackRowDocument, options);
        }
export type RackRowQueryHookResult = ReturnType<typeof useRackRowQuery>;
export type RackRowLazyQueryHookResult = ReturnType<typeof useRackRowLazyQuery>;
export type RackRowQueryResult = Apollo.QueryResult<RackRowQuery, RackRowQueryVariables>;
export function refetchRackRowQuery(variables?: RackRowQueryVariables) {
      return { query: RackRowDocument, variables: variables }
    }
export const RackRowsDocument = gql`
    query rackRows($projectId: ID!, $collectionId: ID!, $offset: Int = 0, $limit: Int = 30, $filters: [RackRowFilter!], $orders: [RackRowOrder!]) {
  total: rackRowsCount(projectId: $projectId, collectionId: $collectionId)
  rackRows(
    projectId: $projectId
    collectionId: $collectionId
    offset: $offset
    limit: $limit
    filters: $filters
    orders: $orders
  ) {
    id
    data
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useRackRowsQuery__
 *
 * To run a query within a React component, call `useRackRowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRackRowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRackRowsQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      collectionId: // value for 'collectionId'
 *      offset: // value for 'offset'
 *      limit: // value for 'limit'
 *      filters: // value for 'filters'
 *      orders: // value for 'orders'
 *   },
 * });
 */
export function useRackRowsQuery(baseOptions: Apollo.QueryHookOptions<RackRowsQuery, RackRowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RackRowsQuery, RackRowsQueryVariables>(RackRowsDocument, options);
      }
export function useRackRowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RackRowsQuery, RackRowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RackRowsQuery, RackRowsQueryVariables>(RackRowsDocument, options);
        }
export type RackRowsQueryHookResult = ReturnType<typeof useRackRowsQuery>;
export type RackRowsLazyQueryHookResult = ReturnType<typeof useRackRowsLazyQuery>;
export type RackRowsQueryResult = Apollo.QueryResult<RackRowsQuery, RackRowsQueryVariables>;
export function refetchRackRowsQuery(variables?: RackRowsQueryVariables) {
      return { query: RackRowsDocument, variables: variables }
    }